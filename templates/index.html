<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ðŸŽ€ Aiko - Ultra Natural Human-Like Chatbot</title>
    <style>
        /* Enhanced Anime Theme */
        :root {
            --anime-pink: #ff6b93;
            --anime-purple: #9d65c9;
            --anime-blue: #6bb5ff;
            --anime-yellow: #ffd166;
            --anime-green: #7ce0b3;
            --bg-gradient: linear-gradient(135deg, #fff0f8 0%, #f0f0ff 100%);
            --card-bg: rgba(255, 255, 255, 0.98);
            --text-dark: #333344;
            --shadow-soft: 0 8px 32px rgba(255, 107, 147, 0.15);
            --shadow-strong: 0 12px 48px rgba(157, 101, 201, 0.25);
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Arial Rounded', sans-serif;
        }
        
        body {
            background: var(--bg-gradient);
            color: var(--text-dark);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            line-height: 1.6;
        }
        
        /* Authentication Screens */
        .auth-container {
            background: var(--card-bg);
            padding: 40px;
            border-radius: 25px;
            box-shadow: var(--shadow-strong);
            width: 100%;
            max-width: 500px;
            margin-top: 50px;
            border: 3px solid rgba(255, 107, 147, 0.15);
            text-align: center;
            backdrop-filter: blur(10px);
            animation: fadeIn 0.5s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .auth-title {
            font-size: 2.8rem;
            background: linear-gradient(45deg, var(--anime-pink), var(--anime-purple));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 15px;
            font-weight: 900;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .auth-subtitle {
            color: var(--anime-purple);
            margin-bottom: 30px;
            opacity: 0.9;
            font-size: 1.1rem;
        }
        
        .auth-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            background: rgba(255, 107, 147, 0.05);
            padding: 5px;
            border-radius: 15px;
        }
        
        .auth-tab {
            flex: 1;
            padding: 15px;
            background: transparent;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: var(--transition);
            font-size: 1rem;
        }
        
        .auth-tab.active {
            background: linear-gradient(135deg, var(--anime-pink), var(--anime-purple));
            color: white;
            box-shadow: 0 4px 12px rgba(255, 107, 147, 0.3);
        }
        
        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .form-group {
            text-align: left;
        }
        
        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-dark);
            font-size: 0.95rem;
        }
        
        .form-input {
            width: 100%;
            padding: 16px 20px;
            background: rgba(248, 249, 255, 0.8);
            border: 2px solid rgba(230, 233, 255, 0.8);
            border-radius: 15px;
            font-size: 1rem;
            transition: var(--transition);
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--anime-pink);
            background: white;
            box-shadow: 0 0 0 4px rgba(255, 107, 147, 0.1);
        }
        
        .auth-btn {
            padding: 18px;
            background: linear-gradient(135deg, var(--anime-pink), var(--anime-purple));
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: var(--transition);
            margin-top: 10px;
            box-shadow: 0 4px 15px rgba(255, 107, 147, 0.3);
        }
        
        .auth-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(255, 107, 147, 0.4);
        }
        
        .auth-btn:active {
            transform: translateY(-1px);
        }
        
        .auth-error {
            color: #ff4757;
            background: rgba(255, 71, 87, 0.1);
            padding: 12px;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
            border-left: 4px solid #ff4757;
        }
        
        .auth-success {
            color: var(--anime-green);
            background: rgba(124, 224, 179, 0.1);
            padding: 12px;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
            border-left: 4px solid var(--anime-green);
        }
        
        /* Chat Interface */
        #chatInterface {
            display: none;
            width: 100%;
            max-width: 1000px;
            animation: fadeIn 0.5s ease-out;
        }
        
        /* User Info Bar */
        .user-bar {
            background: var(--card-bg);
            padding: 20px 30px;
            border-radius: 20px;
            box-shadow: var(--shadow-soft);
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .user-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .user-avatar {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--anime-pink), var(--anime-purple));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 900;
            font-size: 1.5rem;
            box-shadow: 0 4px 12px rgba(255, 107, 147, 0.3);
        }
        
        .user-details {
            flex: 1;
        }
        
        .username {
            font-weight: 800;
            color: var(--text-dark);
            font-size: 1.2rem;
        }
        
        .user-email {
            color: #666;
            font-size: 0.95rem;
            opacity: 0.8;
        }
        
        .logout-btn {
            padding: 12px 25px;
            background: rgba(255, 107, 147, 0.1);
            color: var(--anime-pink);
            border: 2px solid rgba(255, 107, 147, 0.2);
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: var(--transition);
        }
        
        .logout-btn:hover {
            background: linear-gradient(135deg, var(--anime-pink), var(--anime-purple));
            color: white;
            border-color: transparent;
            transform: translateY(-2px);
        }
        
        /* Voice Selection */
        .voice-selector {
            background: var(--card-bg);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: var(--shadow-soft);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .voice-selector h3 {
            color: var(--anime-pink);
            margin-bottom: 20px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .voice-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .voice-card {
            background: white;
            padding: 25px;
            border-radius: 18px;
            cursor: pointer;
            transition: var(--transition);
            border: 3px solid transparent;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        
        .voice-card:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-strong);
        }
        
        .voice-card.active {
            border-color: var(--anime-pink);
            background: linear-gradient(135deg, rgba(255, 107, 147, 0.05), rgba(157, 101, 201, 0.05));
            box-shadow: 0 8px 25px rgba(255, 107, 147, 0.2);
        }
        
        .voice-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            display: block;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }
        
        .voice-name {
            font-weight: 800;
            margin-bottom: 8px;
            color: var(--text-dark);
        }
        
        .voice-description {
            color: #666;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        /* Chat Container */
        .chat-container {
            background: var(--card-bg);
            border-radius: 20px;
            box-shadow: var(--shadow-strong);
            overflow: hidden;
            margin-bottom: 30px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .chat-messages {
            height: 500px;
            padding: 30px;
            overflow-y: auto;
            background: linear-gradient(180deg, #fff9fd 0%, #f9f7ff 100%);
        }
        
        .chat-messages::-webkit-scrollbar {
            width: 10px;
        }
        
        .chat-messages::-webkit-scrollbar-track {
            background: rgba(255, 107, 147, 0.05);
            border-radius: 5px;
        }
        
        .chat-messages::-webkit-scrollbar-thumb {
            background: linear-gradient(var(--anime-pink), var(--anime-purple));
            border-radius: 5px;
        }
        
        /* Message Bubbles */
        .message {
            display: flex;
            gap: 20px;
            max-width: 85%;
            margin-bottom: 25px;
            animation: slideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
            margin-left: auto;
        }
        
        .avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            flex-shrink: 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .bot .avatar {
            background: linear-gradient(135deg, var(--anime-pink), var(--anime-purple));
            color: white;
        }
        
        .user .avatar {
            background: linear-gradient(135deg, var(--anime-blue), var(--anime-yellow));
            color: var(--text-dark);
        }
        
        .message-content {
            padding: 20px 25px;
            border-radius: 20px;
            max-width: 100%;
            word-wrap: break-word;
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .bot .message-content {
            background: white;
            border: 2px solid rgba(255, 107, 147, 0.15);
            border-radius: 20px 20px 20px 8px;
        }
        
        .user .message-content {
            background: linear-gradient(135deg, rgba(107, 181, 255, 0.1), rgba(255, 209, 102, 0.1));
            border: 2px solid rgba(107, 181, 255, 0.2);
            border-radius: 20px 20px 8px 20px;
        }
        
        .message-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: #888;
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid rgba(0,0,0,0.05);
        }
        
        .emotion-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            background: rgba(255, 107, 147, 0.1);
            color: var(--anime-pink);
        }
        
        /* Input Area */
        .input-area {
            padding: 30px;
            background: white;
            border-top: 2px solid rgba(255, 107, 147, 0.1);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .input-row {
            display: flex;
            gap: 20px;
        }
        
        #messageInput {
            flex: 1;
            padding: 20px 25px;
            background: rgba(248, 249, 255, 0.8);
            border: 2px solid rgba(230, 233, 255, 0.8);
            border-radius: 18px;
            font-size: 1rem;
            resize: none;
            min-height: 70px;
            line-height: 1.5;
            transition: var(--transition);
        }
        
        #messageInput:focus {
            outline: none;
            border-color: var(--anime-pink);
            background: white;
            box-shadow: 0 0 0 4px rgba(255, 107, 147, 0.1);
        }
        
        #messageInput::placeholder {
            color: #999;
            opacity: 0.7;
        }
        
        .chat-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .chat-btn {
            padding: 20px 35px;
            background: linear-gradient(135deg, var(--anime-pink), var(--anime-purple));
            color: white;
            border: none;
            border-radius: 18px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            min-width: 160px;
            transition: var(--transition);
            box-shadow: 0 4px 15px rgba(255, 107, 147, 0.3);
        }
        
        .chat-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(255, 107, 147, 0.4);
        }
        
        .voice-toggle {
            padding: 15px 25px;
            background: rgba(124, 224, 179, 0.1);
            color: var(--anime-green);
            border: 2px solid rgba(124, 224, 179, 0.2);
            border-radius: 15px;
            cursor: pointer;
            font-weight: 600;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .voice-toggle:hover {
            background: rgba(124, 224, 179, 0.2);
        }
        
        .voice-toggle.active {
            background: var(--anime-green);
            color: white;
        }
        
        /* Status Indicator */
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            margin-top: 20px;
            align-self: flex-start;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--anime-green);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .auth-container {
                padding: 30px 20px;
                margin-top: 20px;
            }
            
            .voice-grid {
                grid-template-columns: 1fr;
            }
            
            .user-bar {
                flex-direction: column;
                gap: 20px;
                text-align: center;
            }
            
            .input-row {
                flex-direction: column;
            }
            
            .chat-controls {
                flex-direction: column;
                width: 100%;
            }
            
            .chat-btn, .voice-toggle {
                width: 100%;
                justify-content: center;
            }
            
            .message {
                max-width: 95%;
            }
        }
        
        @media (max-width: 480px) {
            .auth-title {
                font-size: 2.2rem;
            }
            
            .chat-messages {
                padding: 20px;
                height: 400px;
            }
            
            .voice-card {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Authentication Screen -->
    <div class="auth-container" id="authContainer">
        <h1 class="auth-title">ðŸŽ€ AIKO</h1>
        <div class="auth-subtitle">Ultra Natural Human-Like Chatbot with Gemini AI</div>
        
        <div class="auth-tabs">
            <button class="auth-tab active" id="loginTab">Login</button>
            <button class="auth-tab" id="registerTab">Register</button>
        </div>
        
        <!-- Login Form -->
        <form class="auth-form" id="loginForm" style="display: block;">
            <div class="form-group">
                <label class="form-label">Username</label>
                <input type="text" class="form-input" id="loginUsername" required autocomplete="username">
            </div>
            <div class="form-group">
                <label class="form-label">Password</label>
                <input type="password" class="form-input" id="loginPassword" required autocomplete="current-password">
            </div>
            <button type="submit" class="auth-btn">Login</button>
        </form>
        
        <!-- Register Form -->
        <form class="auth-form" id="registerForm" style="display: none;">
            <div class="form-group">
                <label class="form-label">Username</label>
                <input type="text" class="form-input" id="regUsername" required autocomplete="username">
            </div>
            <div class="form-group">
                <label class="form-label">Email</label>
                <input type="email" class="form-input" id="regEmail" required autocomplete="email">
            </div>
            <div class="form-group">
                <label class="form-label">Password</label>
                <input type="password" class="form-input" id="regPassword" required autocomplete="new-password">
            </div>
            <button type="submit" class="auth-btn">Create Account</button>
        </form>
        
        <div class="auth-error" id="authError"></div>
        <div class="auth-success" id="authSuccess"></div>
    </div>
    
    <!-- Chat Interface -->
    <div id="chatInterface">
        <!-- User Info Bar -->
        <div class="user-bar">
            <div class="user-info">
                <div class="user-avatar" id="userAvatar">A</div>
                <div class="user-details">
                    <div class="username" id="displayUsername">Loading...</div>
                    <div class="user-email" id="displayEmail">Loading...</div>
                </div>
            </div>
            <button class="logout-btn" id="logoutBtn">
                <span>Logout</span>
            </button>
        </div>
        
        <!-- Voice Selection -->
        <div class="voice-selector">
            <h3>ðŸŽ­ Choose Aiko's Personality Style</h3>
            <div class="voice-grid" id="voiceGrid">
                <!-- Voice cards will be populated by JavaScript -->
            </div>
        </div>
        
        <!-- Chat Container -->
        <div class="chat-container">
            <div class="chat-messages" id="chatMessages">
                <!-- Welcome message -->
                <div class="message bot">
                    <div class="avatar">A</div>
                    <div class="message-content">
                        <div class="message-text">Hey there! I'm Aiko, your ultra-natural conversation partner! ðŸ˜Š</div>
                        <div class="message-meta">
                            <span class="emotion-badge">Happy</span>
                            <span class="message-time">Just now</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="input-area">
                <div class="input-row">
                    <textarea 
                        id="messageInput" 
                        placeholder="Type your message here... (I'll respond like a real human! ðŸ—£ï¸)"
                        rows="3"
                        autocomplete="off"></textarea>
                </div>
                <div class="chat-controls">
                    <button class="voice-toggle" id="voiceToggle">
                        <span>ðŸŽ¤ Voice Input</span>
                    </button>
                    <button class="chat-btn" id="sendBtn">
                        <span>Send Message</span>
                    </button>
                </div>
                <div class="status-indicator" id="statusIndicator">
                    <div class="status-dot"></div>
                    <span id="statusText">AI is ready for natural conversation</span>
                </div>
            </div>
        </div>
    </div>
    
    <script>
    // --- Global Variables ---
    let authToken = localStorage.getItem('auth_token');
    let currentUser = null;
    let currentVoice = 'natural';
    let currentConversation = `conv_${Date.now()}`;
    let isListening = false;
    let recognition = null;
    let geminiApiKey = null; // Will be set from environment or user input

    // Voice styles mapped to Gemini voices
    const voiceStyles = {
        'natural': { 
            name: 'Natural Human ðŸ—£ï¸', 
            icon: 'ðŸ—£ï¸',
            description: 'Normal conversational tone with realistic imperfections',
            geminiVoice: 'Kore' // Natural female voice
        },
        'warm': { 
            name: 'Warm & Friendly ðŸ˜Š', 
            icon: 'ðŸ˜Š',
            description: 'Caring, empathetic, and supportive conversations',
            geminiVoice: 'Lyra' // Warm, caring voice
        },
        'energetic': { 
            name: 'Energetic âš¡', 
            icon: 'âš¡',
            description: 'Excited, enthusiastic, and motivational',
            geminiVoice: 'Iris' // Energetic female voice
        },
        'calm': { 
            name: 'Calm & Soothing ðŸƒ', 
            icon: 'ðŸƒ',
            description: 'Peaceful, gentle, and relaxing dialogue',
            geminiVoice: 'Sage' // Calm, soothing voice
        },
        'playful': { 
            name: 'Playful ðŸ˜„', 
            icon: 'ðŸ˜„',
            description: 'Fun, light-hearted, and humorous chats',
            geminiVoice: 'Zoe' // Playful, animated voice
        }
    };

    // --- Gemini TTS Engine ---
    class GeminiTTSEngine {
        constructor() {
            this.isSpeaking = false;
            this.audioContext = null;
            this.currentAudio = null;
            this.availableVoices = {
                'Kore': 'neutral-natural-female',
                'Lyra': 'warm-friendly-female',
                'Iris': 'energetic-female',
                'Sage': 'calm-soothing-female',
                'Zoe': 'playful-animated-female',
                'Nova': 'clear-professional-female',
                'Coral': 'expressive-young-female'
            };
        }

        // Convert PCM to WAV (from your other project)
        pcmToWav(pcmData, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2; // 16-bit PCM
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcmData.byteLength;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            let offset = 0;
            const writeString = (str) => {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset + i, str.charCodeAt(i));
                }
                offset += str.length;
            };

            // RIFF chunk
            writeString('RIFF');
            view.setUint32(offset, 36 + dataSize, true); offset += 4;
            writeString('WAVE');

            // FMT chunk
            writeString('fmt ');
            view.setUint32(offset, 16, true); offset += 4;      // Chunk size
            view.setUint16(offset, 1, true); offset += 2;       // Audio format (1 = PCM)
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, byteRate, true); offset += 4;
            view.setUint16(offset, blockAlign, true); offset += 2;
            view.setUint16(offset, 16, true); offset += 2;      // Bits per sample

            // DATA chunk
            writeString('data');
            view.setUint32(offset, dataSize, true); offset += 4;

            // Copy PCM data
            const pcmView = new Int16Array(pcmData);
            for (let i = 0; i < pcmView.length; i++) {
                view.setInt16(offset, pcmView[i], true);
                offset += 2;
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        async generateSpeech(text, voiceName = 'Kore') {
            if (!geminiApiKey) {
                console.warn('No Gemini API key available, using fallback Web Speech');
                return this.fallbackSpeech(text, voiceName);
            }

            try {
                updateStatus('Generating human-like voice...');
                
                const payload = {
                    contents: [{ parts: [{ text: text }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: voiceName }
                            }
                        }
                    },
                    model: "gemini-2.5-flash-preview-tts"
                };

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${geminiApiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`TTS API error: ${response.status}`);
                }

                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000;
                    
                    const pcmData = this.base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = this.pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    return audioUrl;
                } else {
                    throw new Error('Invalid audio data received');
                }
            } catch (error) {
                console.error('Gemini TTS error:', error);
                updateStatus('Using high-quality fallback voice');
                return this.fallbackSpeech(text, voiceName);
            }
        }

        fallbackSpeech(text, voiceName) {
            return new Promise((resolve) => {
                if (!('speechSynthesis' in window)) {
                    resolve(null);
                    return;
                }

                const utterance = new SpeechSynthesisUtterance(text);
                
                // Try to find the best available voice
                const voices = speechSynthesis.getVoices();
                let selectedVoice = null;
                
                // Map Gemini voice names to available voices
                const voiceMapping = {
                    'Kore': ['Samantha', 'Google UK English Female', 'Microsoft Zira'],
                    'Lyra': ['Karen', 'Microsoft Eva'],
                    'Iris': ['Tessa', 'Google US English Female'],
                    'Sage': ['Moira', 'English (Ireland)'],
                    'Zoe': ['Fiona', 'English (Scotland)']
                };

                const voiceOptions = voiceMapping[voiceName] || voiceMapping['Kore'];
                
                for (const option of voiceOptions) {
                    const found = voices.find(v => v.name.includes(option));
                    if (found) {
                        selectedVoice = found;
                        break;
                    }
                }

                if (!selectedVoice && voices.length > 0) {
                    // Find any female voice
                    selectedVoice = voices.find(v => 
                        v.name.toLowerCase().includes('female') || 
                        v.name.toLowerCase().includes('samantha') ||
                        v.name.toLowerCase().includes('zira')
                    ) || voices[0];
                }

                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                }

                // Adjust pitch based on voice style
                const pitchMap = {
                    'Kore': 1.35,
                    'Lyra': 1.32,
                    'Iris': 1.45,
                    'Sage': 1.28,
                    'Zoe': 1.42
                };

                utterance.pitch = pitchMap[voiceName] || 1.35;
                utterance.rate = 0.95;
                utterance.volume = 1.0;

                // Convert to audio URL for consistent interface
                const audioChunks = [];
                const mediaRecorder = new MediaRecorder(new MediaStream());
                
                // This is simplified - in reality we'd need to capture audio output
                // For now, we'll just speak directly
                speechSynthesis.speak(utterance);
                
                utterance.onend = () => {
                    resolve(null); // No audio URL for fallback
                };
                
                utterance.onerror = () => {
                    resolve(null);
                };
            });
        }

        async speak(text, voiceStyle = 'natural') {
            if (this.isSpeaking) {
                this.stop();
            }

            const voiceConfig = voiceStyles[voiceStyle] || voiceStyles.natural;
            const geminiVoice = voiceConfig.geminiVoice;
            
            // Clean the text
            const cleanText = text.replace(/\[.*?\]/g, '').trim();
            if (!cleanText) return;

            this.isSpeaking = true;
            updateStatus('Aiko is speaking...');

            try {
                const audioUrl = await this.generateSpeech(cleanText, geminiVoice);
                
                if (audioUrl) {
                    this.currentAudio = new Audio(audioUrl);
                    this.currentAudio.play();
                    
                    this.currentAudio.onended = () => {
                        this.isSpeaking = false;
                        updateStatus('Ready for natural conversation');
                        URL.revokeObjectURL(audioUrl);
                    };
                    
                    this.currentAudio.onerror = () => {
                        this.isSpeaking = false;
                        updateStatus('Voice playback error');
                        URL.revokeObjectURL(audioUrl);
                    };
                } else {
                    // Fallback to Web Speech
                    if ('speechSynthesis' in window) {
                        const utterance = new SpeechSynthesisUtterance(cleanText);
                        const voices = speechSynthesis.getVoices();
                        const femaleVoice = voices.find(v => v.name.includes('Female')) || voices[0];
                        
                        if (femaleVoice) utterance.voice = femaleVoice;
                        utterance.pitch = voiceStyle === 'energetic' ? 1.45 : 1.35;
                        utterance.rate = 0.95;
                        
                        utterance.onend = () => {
                            this.isSpeaking = false;
                            updateStatus('Ready for natural conversation');
                        };
                        
                        utterance.onerror = () => {
                            this.isSpeaking = false;
                            updateStatus('Voice error');
                        };
                        
                        speechSynthesis.speak(utterance);
                    } else {
                        this.isSpeaking = false;
                        updateStatus('Voice not available');
                    }
                }
            } catch (error) {
                console.error('Speech error:', error);
                this.isSpeaking = false;
                updateStatus('Voice generation failed');
            }
        }

        stop() {
            if (this.currentAudio) {
                this.currentAudio.pause();
                this.currentAudio.currentTime = 0;
            }
            speechSynthesis.cancel();
            this.isSpeaking = false;
        }

        setApiKey(key) {
            geminiApiKey = key;
        }
    }

    // Initialize TTS Engine
    const ttsEngine = new GeminiTTSEngine();

    // --- DOM Elements ---
    const authContainer = document.getElementById('authContainer');
    const chatInterface = document.getElementById('chatInterface');
    const loginTab = document.getElementById('loginTab');
    const registerTab = document.getElementById('registerTab');
    const loginForm = document.getElementById('loginForm');
    const registerForm = document.getElementById('registerForm');
    const authError = document.getElementById('authError');
    const authSuccess = document.getElementById('authSuccess');
    const userAvatar = document.getElementById('userAvatar');
    const displayUsername = document.getElementById('displayUsername');
    const displayEmail = document.getElementById('displayEmail');
    const logoutBtn = document.getElementById('logoutBtn');
    const voiceGrid = document.getElementById('voiceGrid');
    const chatMessages = document.getElementById('chatMessages');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const voiceToggle = document.getElementById('voiceToggle');
    const statusText = document.getElementById('statusText');

    // --- Authentication Functions ---
    function showAuthError(message) {
        authError.textContent = message;
        authError.style.display = 'block';
        authSuccess.style.display = 'none';
    }

    function showAuthSuccess(message) {
        authSuccess.textContent = message;
        authSuccess.style.display = 'block';
        authError.style.display = 'none';
    }

    function clearAuthMessages() {
        authError.style.display = 'none';
        authSuccess.style.display = 'none';
    }

    // --- Tab Switching ---
    loginTab.addEventListener('click', () => {
        loginTab.classList.add('active');
        registerTab.classList.remove('active');
        loginForm.style.display = 'block';
        registerForm.style.display = 'none';
        clearAuthMessages();
    });

    registerTab.addEventListener('click', () => {
        registerTab.classList.add('active');
        loginTab.classList.remove('active');
        registerForm.style.display = 'block';
        loginForm.style.display = 'none';
        clearAuthMessages();
    });

    // --- Login Handler ---
    loginForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        clearAuthMessages();
        
        const username = document.getElementById('loginUsername').value.trim();
        const password = document.getElementById('loginPassword').value.trim();
        
        if (!username || !password) {
            showAuthError('Please fill in all fields');
            return;
        }
        
        try {
            updateStatus('Authenticating...');
            const response = await fetch('/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password })
            });
            
            const data = await response.json();
            
            if (data.status === 'success') {
                // Save token and user info
                authToken = data.token;
                localStorage.setItem('auth_token', authToken);
                currentUser = {
                    id: data.user_id,
                    username: data.username,
                    email: data.email
                };
                
                // Switch to chat interface
                showChatInterface();
                loadUserProfile();
                loadChatHistory();
                updateStatus('Ready for natural conversation');
            } else {
                showAuthError(data.message);
                updateStatus('Authentication failed');
            }
        } catch (error) {
            showAuthError('Network error. Please try again.');
            console.error('Login error:', error);
            updateStatus('Connection error');
        }
    });

    // --- Registration Handler ---
    registerForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        clearAuthMessages();
        
        const username = document.getElementById('regUsername').value.trim();
        const email = document.getElementById('regEmail').value.trim();
        const password = document.getElementById('regPassword').value.trim();
        
        // Validation
        if (username.length < 3) {
            showAuthError('Username must be at least 3 characters');
            return;
        }
        
        if (password.length < 6) {
            showAuthError('Password must be at least 6 characters');
            return;
        }
        
        if (!email.includes('@') || !email.includes('.')) {
            showAuthError('Please enter a valid email address');
            return;
        }
        
        try {
            updateStatus('Creating account...');
            const response = await fetch('/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, email, password })
            });
            
            const data = await response.json();
            
            if (data.status === 'success') {
                showAuthSuccess('Account created successfully! Please login.');
                updateStatus('Account created');
                // Switch to login tab
                loginTab.click();
                document.getElementById('loginUsername').value = username;
                document.getElementById('loginPassword').value = '';
            } else {
                showAuthError(data.message);
                updateStatus('Registration failed');
            }
        } catch (error) {
            showAuthError('Network error. Please try again.');
            console.error('Registration error:', error);
            updateStatus('Connection error');
        }
    });

    // --- Chat Interface Functions ---
    function showChatInterface() {
        authContainer.style.display = 'none';
        chatInterface.style.display = 'block';
        
        // Initialize voice selection
        initializeVoiceSelection();
        
        // Initialize voice recognition if available
        initializeVoiceRecognition();
        
        // Focus on input
        setTimeout(() => {
            messageInput.focus();
        }, 100);
    }

    function showAuthInterface() {
        authContainer.style.display = 'block';
        chatInterface.style.display = 'none';
        clearAuthMessages();
        updateStatus('Please login or register');
    }

    function initializeVoiceSelection() {
        voiceGrid.innerHTML = '';
        
        for (const [key, style] of Object.entries(voiceStyles)) {
            const card = document.createElement('div');
            card.className = `voice-card ${key === currentVoice ? 'active' : ''}`;
            card.dataset.voice = key;
            card.innerHTML = `
                <span class="voice-icon">${style.icon}</span>
                <div class="voice-name">${style.name}</div>
                <div class="voice-description">${style.description}</div>
                <div class="text-xs mt-2 text-gray-500">Voice: ${style.geminiVoice}</div>
            `;
            
            card.addEventListener('click', () => {
                document.querySelectorAll('.voice-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                currentVoice = key;
                updateStatus(`Switched to ${style.name} (${style.geminiVoice} voice)`);
                
                // Update user preferences
                updateVoicePreference(key);
            });
            
            voiceGrid.appendChild(card);
        }
    }

    async function updateVoicePreference(voiceStyle) {
        if (!authToken) return;
        
        try {
            await fetch('/preferences', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': authToken
                },
                body: JSON.stringify({ voice_style: voiceStyle })
            });
        } catch (error) {
            console.error('Error updating voice preference:', error);
        }
    }

    // --- Voice Recognition ---
    function initializeVoiceRecognition() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';
            
            recognition.onstart = () => {
                isListening = true;
                voiceToggle.classList.add('active');
                voiceToggle.innerHTML = '<span>ðŸŽ¤ Listening...</span>';
                updateStatus('Listening... Speak now');
            };
            
            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                messageInput.value = transcript;
                
                // Auto-send if it sounds like a complete thought
                if (transcript.trim().length > 3 && 
                    (transcript.endsWith('.') || transcript.endsWith('?') || transcript.endsWith('!'))) {
                    setTimeout(() => {
                        sendMessage();
                    }, 500);
                }
            };
            
            recognition.onend = () => {
                isListening = false;
                voiceToggle.classList.remove('active');
                voiceToggle.innerHTML = '<span>ðŸŽ¤ Voice Input</span>';
                updateStatus('Ready for natural conversation');
            };
            
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                updateStatus('Voice input error');
            };
            
            voiceToggle.addEventListener('click', () => {
                if (!isListening) {
                    recognition.start();
                } else {
                    recognition.stop();
                }
            });
        } else {
            voiceToggle.style.display = 'none';
            console.log('Speech recognition not supported');
        }
    }

    // --- User Profile ---
    async function loadUserProfile() {
        if (!authToken) return;
        
        try {
            const response = await fetch('/profile', {
                headers: {
                    'Authorization': authToken
                }
            });
            
            const data = await response.json();
            
            if (data.status === 'success') {
                // Update display
                displayUsername.textContent = data.profile.username;
                displayEmail.textContent = data.profile.email;
                
                // Set avatar initial
                userAvatar.textContent = data.profile.username.charAt(0).toUpperCase();
                
                // Load preferences
                loadUserPreferences();
            }
        } catch (error) {
            console.error('Error loading profile:', error);
        }
    }

    async function loadUserPreferences() {
        try {
            const response = await fetch('/preferences', {
                headers: { 'Authorization': authToken }
            });
            
            const data = await response.json();
            if (data.status === 'success') {
                currentVoice = data.preferences.voice_style || 'natural';
                initializeVoiceSelection();
            }
        } catch (error) {
            console.error('Error loading preferences:', error);
        }
    }

    // --- Chat History ---
    async function loadChatHistory() {
        if (!authToken) return;
        
        try {
            const response = await fetch('/history', {
                headers: { 'Authorization': authToken }
            });
            
            const data = await response.json();
            if (data.status === 'success' && data.messages.length > 0) {
                // Clear current messages except welcome
                const welcomeMsg = chatMessages.querySelector('.message:first-child');
                chatMessages.innerHTML = '';
                if (welcomeMsg) chatMessages.appendChild(welcomeMsg);
                
                // Add messages in chronological order
                data.messages.reverse().forEach(msg => {
                    addMessageToChat(msg.role === 'user' ? 'user' : 'bot', msg.content, msg.emotion);
                });
            }
        } catch (error) {
            console.error('Error loading history:', error);
        }
    }

    // --- Chat Functions ---
    function addMessageToChat(type, content, emotion = null, shouldSpeak = true) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}`;
    
    const avatar = document.createElement('div');
    avatar.className = 'avatar';
    avatar.textContent = type === 'bot' ? 'A' : 'You';
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';
    
    // Clean content for display (remove tags)
    const displayContent = content.replace(/\[.*?\]/g, '').trim();
    
    const textDiv = document.createElement('div');
    textDiv.className = 'message-text';
    textDiv.textContent = displayContent;
    
    const metaDiv = document.createElement('div');
    metaDiv.className = 'message-meta';
    
    const emotionSpan = document.createElement('span');
    emotionSpan.className = 'emotion-badge';
    emotionSpan.textContent = emotion || 'Neutral';
    
    const timeSpan = document.createElement('span');
    timeSpan.className = 'message-time';
    timeSpan.textContent = new Date().toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit' 
    });
    
    metaDiv.appendChild(emotionSpan);
    metaDiv.appendChild(timeSpan);
    
    contentDiv.appendChild(textDiv);
    contentDiv.appendChild(metaDiv);
    
    messageDiv.appendChild(avatar);
    messageDiv.appendChild(contentDiv);
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Speak the message if it's from bot AND shouldSpeak is true
    if (type === 'bot' && shouldSpeak) {
        // Small delay for natural feel
        setTimeout(() => {
            speakMessage(content);
        }, 300);
    }
}

    function speakMessage(text) {
        if (ttsEngine) {
            ttsEngine.speak(text, currentVoice);
        }
    }

    async function sendMessage() {
        const message = messageInput.value.trim();
        if (!message || !authToken) return;
        
        // Clear input but keep focus
        messageInput.value = '';
        messageInput.style.height = 'auto';
        messageInput.focus();
        
        // Add user message to chat
        addMessageToChat('user', message);
        
        try {
            updateStatus('Aiko is thinking...');
            
            const response = await fetch('/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': authToken
                },
                body: JSON.stringify({
                    message: message,
                    voice_style: currentVoice,
                    conversation_id: currentConversation
                })
            });
            
            const data = await response.json();
            
            if (data.status === 'success') {
                // Add bot response to chat
                addMessageToChat('bot', data.text, data.emotion);
                
                if (data.gemini_used) {
                    updateStatus('Gemini AI response generated');
                } else {
                    updateStatus('Enhanced fallback response');
                }
            } else {
                addMessageToChat('bot', 'Hmm, I seem to have encountered a small hiccup there. Could you try that again?', 'thoughtful');
                updateStatus('Error in response generation');
            }
        } catch (error) {
            console.error('Error sending message:', error);
            addMessageToChat('bot', 'Oh dear, I seem to be having connection issues. Mind trying again in a moment?', 'concerned');
            updateStatus('Network error occurred');
        }
    }

    // --- Status Updates ---
    function updateStatus(text) {
        statusText.textContent = text;
    }

    // --- Logout Handler ---
    logoutBtn.addEventListener('click', async () => {
        try {
            updateStatus('Logging out...');
            await fetch('/logout', {
                method: 'POST',
                headers: { 'Authorization': authToken }
            });
            
            // Clear local data
            localStorage.removeItem('auth_token');
            authToken = null;
            currentUser = null;
            
            // Stop any ongoing speech
            if (ttsEngine) {
                ttsEngine.stop();
            }
            
            // Show auth interface
            showAuthInterface();
            
            // Clear forms
            loginForm.reset();
            registerForm.reset();
            
            updateStatus('Logged out successfully');
            
        } catch (error) {
            console.error('Logout error:', error);
            updateStatus('Logout error');
        }
    });

    // --- Event Listeners ---
    sendBtn.addEventListener('click', sendMessage);
    
    messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    
    messageInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 150) + 'px';
    });
    
    // Auto-resize on paste
    messageInput.addEventListener('paste', function() {
        setTimeout(() => {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 150) + 'px';
        }, 0);
    });

    // --- Initialize App ---
    document.addEventListener('DOMContentLoaded', async () => {
        // Try to get Gemini API key from environment
        try {
            const statusResponse = await fetch('/status');
            const statusData = await statusResponse.json();
            
            if (statusData.gemini_ai === 'connected') {
                // The backend already has the API key, we'll use it through our backend
                updateStatus('Gemini AI connected');
            } else {
                updateStatus('Using enhanced voice system');
            }
        } catch (error) {
            console.error('Status check failed:', error);
        }
        
        // Check if user is already logged in
        if (authToken) {
            try {
                const response = await fetch('/profile', {
                    headers: { 'Authorization': authToken }
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    currentUser = {
                        id: data.profile.user_id,
                        username: data.profile.username,
                        email: data.profile.email
                    };
                    showChatInterface();
                    loadUserProfile();
                    loadChatHistory();
                    updateStatus('Ready for natural conversation');
                } else {
                    // Invalid token
                    localStorage.removeItem('auth_token');
                    showAuthInterface();
                }
            } catch (error) {
                showAuthInterface();
            }
        } else {
            showAuthInterface();
        }
        
        // Add some interactive effects
        document.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                const button = e.target.closest('button');
                button.style.transform = 'scale(0.98)';
                setTimeout(() => {
                    button.style.transform = '';
                }, 150);
            }
        });
        
        // Test voice system after load
        setTimeout(() => {
            if (ttsEngine) {
                const testPhrase = "Hello! I'm Aiko, ready for natural conversation with you.";
                ttsEngine.speak(testPhrase, 'natural');
            }
        }, 2000);
    });

    // Handle page visibility changes
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            // Stop speech when page is hidden
            if (ttsEngine) {
                ttsEngine.stop();
            }
            if (recognition && isListening) {
                recognition.stop();
            }
        }
    });

    // --- API Key Setup (Optional) ---
    // You can add a settings panel to let users input their own Gemini API key
    function setupApiKeyInput() {
        const apiKey = localStorage.getItem('gemini_api_key');
        if (apiKey) {
            ttsEngine.setApiKey(apiKey);
        } else {
            // Optionally show a modal to input API key
            // const apiKey = prompt('Enter Gemini API key for premium voice:');
            // if (apiKey) {
            //     localStorage.setItem('gemini_api_key', apiKey);
            //     ttsEngine.setApiKey(apiKey);
            // }
        }
    }
    
    // Call setup on load
    setupApiKeyInput();
</script>
</body>
</html>